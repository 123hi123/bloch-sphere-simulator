<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>å‹•ç•«ç‰ˆ Bloch çƒé‡å­é–€æ¨¡æ“¬å™¨ï¼ˆæ”¹é€²æ§åˆ¶ï¼‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: 30px;
        }
        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
        }
        .camera-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        .camera-btn {
            padding: 8px 16px;
            background-color: rgba(33, 150, 243, 0.9);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        .camera-btn:hover {
            background-color: rgba(33, 150, 243, 1);
            transform: translateY(-1px);
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .gate-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .gate-btn {
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .gate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .gate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .tooltip {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 5px;
        }
        .gate-btn:hover .tooltip {
            display: block;
        }
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0,0,0,0.9);
        }
        .gate-x { background-color: #f44336; color: white; }
        .gate-y { background-color: #4caf50; color: white; }
        .gate-z { background-color: #2196f3; color: white; }
        .gate-h { background-color: #ff9800; color: white; }
        .gate-s { background-color: #9c27b0; color: white; }
        .gate-t { background-color: #795548; color: white; }
        .gate-rx { background-color: #e91e63; color: white; }
        .gate-ry { background-color: #00bcd4; color: white; }
        .gate-rz { background-color: #ffc107; color: black; }
        .gate-reset { background-color: #607d8b; color: white; }
        
        .state-info {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }
        .complex-state {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .phase-display {
            font-size: 16px;
            color: #333;
            margin-top: 5px;
            font-weight: bold;
        }
        .history {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        .history-item {
            padding: 5px;
            margin: 2px 0;
            background-color: white;
            border-radius: 3px;
            font-size: 12px;
        }
        .measurement-prob {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .prob-bar {
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        .prob-fill {
            height: 100%;
            background-color: #4caf50;
            transition: width 0.3s ease;
        }
        h1 { text-align: center; color: #333; }
        h3 { color: #666; margin-top: 20px; }
        .axis-info {
            background-color: #e3f2fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        .axis-info div {
            margin: 3px 0;
        }
        .x-axis { color: #f44336; font-weight: bold; }
        .y-axis { color: #4caf50; font-weight: bold; }
        .z-axis { color: #2196f3; font-weight: bold; }
        .animation-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .speed-control {
            flex: 1;
        }
        .speed-control label {
            font-size: 12px;
            color: #666;
        }
        .speed-slider {
            width: 100%;
            margin-top: 5px;
        }
        #animation-status {
            text-align: center;
            padding: 10px;
            background-color: #fff3e0;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .control-tip {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        .rotation-controls {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .angle-slider {
            width: 100%;
            margin: 10px 0;
        }
        .angle-display {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒ å‹•ç•«ç‰ˆ Bloch çƒé‡å­é–€æ¨¡æ“¬å™¨ï¼ˆæ”¹é€²æ§åˆ¶ï¼‰</h1>
        
        <div class="main-content">
            <div>
                <div id="canvas-container">
                    <div class="camera-controls">
                        <button class="camera-btn" onclick="resetCamera()">ğŸ¥ é‡ç½®è¦–è§’</button>
                        <button class="camera-btn" onclick="toggleAutoRotate()">ğŸ”„ è‡ªå‹•æ—‹è½‰</button>
                    </div>
                    <div class="control-tip">
                        ğŸ–±ï¸ å·¦éµæ‹–å‹•ï¼šæ—‹è½‰ | å³éµæ‹–å‹•ï¼šå¹³ç§» | æ»¾è¼ªï¼šç¸®æ”¾
                    </div>
                </div>
                <div id="animation-status">æº–å‚™å°±ç·’</div>
            </div>
            
            <div class="controls">
                <div class="axis-info">
                    <div><span class="x-axis">X è»¸ï¼š</span>å¯¦éƒ¨ç–ŠåŠ æ…‹ |+âŸ© å’Œ |-âŸ©</div>
                    <div><span class="y-axis">Y è»¸ï¼š</span>è™›éƒ¨ç–ŠåŠ æ…‹ |+iâŸ© å’Œ |-iâŸ©</div>
                    <div><span class="z-axis">Z è»¸ï¼š</span>è¨ˆç®—åŸºæ…‹ |0âŸ©ï¼ˆåŒ—æ¥µï¼‰å’Œ |1âŸ©ï¼ˆå—æ¥µï¼‰</div>
                </div>
                
                <div>
                    <h3>é‡å­é–€æ§åˆ¶</h3>
                    <div class="gate-buttons">
                        <button class="gate-btn gate-x" onclick="applyGate('X')">
                            X é–€
                            <div class="tooltip">ç¹ X è»¸æ—‹è½‰ 180Â°<br>|0âŸ© â†” |1âŸ©ï¼ˆä½å…ƒç¿»è½‰ï¼‰</div>
                        </button>
                        <button class="gate-btn gate-y" onclick="applyGate('Y')">
                            Y é–€
                            <div class="tooltip">ç¹ Y è»¸æ—‹è½‰ 180Â°<br>|0âŸ© â†’ i|1âŸ©, |1âŸ© â†’ -i|0âŸ©</div>
                        </button>
                        <button class="gate-btn gate-z" onclick="applyGate('Z')">
                            Z é–€
                            <div class="tooltip">ç¹ Z è»¸æ—‹è½‰ 180Â°<br>|1âŸ© â†’ -|1âŸ©ï¼ˆç›¸ä½ç¿»è½‰ï¼‰</div>
                        </button>
                        <button class="gate-btn gate-h" onclick="applyGate('H')">
                            H é–€
                            <div class="tooltip">å‰µå»ºç–ŠåŠ æ…‹<br>|0âŸ© â†’ (|0âŸ©+|1âŸ©)/âˆš2<br>|1âŸ© â†’ (|0âŸ©-|1âŸ©)/âˆš2</div>
                        </button>
                        <button class="gate-btn gate-s" onclick="applyGate('S')">
                            S é–€
                            <div class="tooltip">ç¹ Z è»¸æ—‹è½‰ 90Â°<br>|1âŸ© â†’ i|1âŸ©ï¼ˆÏ€/2 ç›¸ä½ï¼‰</div>
                        </button>
                        <button class="gate-btn gate-t" onclick="applyGate('T')">
                            T é–€
                            <div class="tooltip">ç¹ Z è»¸æ—‹è½‰ 45Â°<br>|1âŸ© â†’ e^(iÏ€/4)|1âŸ©ï¼ˆÏ€/4 ç›¸ä½ï¼‰</div>
                        </button>
                    </div>
                    
                    <div class="rotation-controls">
                        <h4>æ—‹è½‰é–€æ§åˆ¶</h4>
                        <div class="angle-display">æ—‹è½‰è§’åº¦: <span id="rotation-angle">90</span>Â°</div>
                        <input type="range" id="angle-slider" class="angle-slider" 
                               min="0" max="360" value="90" step="1">
                        <div class="gate-buttons" style="margin-top: 10px;">
                            <button class="gate-btn gate-rx" onclick="applyRotationGate('Rx')">
                                Rx(Î¸)
                                <div class="tooltip">ç¹ X è»¸æ—‹è½‰ Î¸ åº¦</div>
                            </button>
                            <button class="gate-btn gate-ry" onclick="applyRotationGate('Ry')">
                                Ry(Î¸)
                                <div class="tooltip">ç¹ Y è»¸æ—‹è½‰ Î¸ åº¦</div>
                            </button>
                            <button class="gate-btn gate-rz" onclick="applyRotationGate('Rz')">
                                Rz(Î¸)
                                <div class="tooltip">ç¹ Z è»¸æ—‹è½‰ Î¸ åº¦</div>
                            </button>
                        </div>
                    </div>
                    
                    <button class="gate-btn gate-reset" onclick="resetState()" style="width: 100%; margin-top: 10px;">
                        é‡ç½®åˆ° |0âŸ©
                        <div class="tooltip">å›åˆ°åˆå§‹ç‹€æ…‹ |0âŸ©</div>
                    </button>
                </div>
                
                <div class="animation-controls">
                    <div class="speed-control">
                        <label for="speed-slider">å‹•ç•«é€Ÿåº¦</label>
                        <input type="range" id="speed-slider" class="speed-slider" 
                               min="500" max="3000" value="1500" step="100">
                        <span id="speed-value">1.5 ç§’</span>
                    </div>
                </div>
                
                <div class="state-info">
                    <h3>ç•¶å‰é‡å­æ…‹</h3>
                    <div id="state-vector" class="phase-display">|ÏˆâŸ© = 1.00|0âŸ© + 0.00|1âŸ©</div>
                    <div id="complex-state" class="complex-state"></div>
                    <div id="bloch-coords">Bloch åº§æ¨™: (0.00, 0.00, 1.00)</div>
                    <div id="angles">Î¸ = 0.00Â°, Ï† = 0.00Â°</div>
                    
                    <h4>æ¸¬é‡æ©Ÿç‡</h4>
                    <div class="measurement-prob">
                        <div>
                            <div>|0âŸ©: <span id="prob0">100.0%</span></div>
                            <div class="prob-bar">
                                <div class="prob-fill" id="prob0-bar" style="width: 100%"></div>
                            </div>
                        </div>
                        <div>
                            <div>|1âŸ©: <span id="prob1">0.0%</span></div>
                            <div class="prob-bar">
                                <div class="prob-fill" id="prob1-bar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="history">
                    <h3>æ“ä½œæ­·å²</h3>
                    <div id="history-list"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ä¸‰ç¶­å ´æ™¯è¨­ç½®
        let scene, camera, renderer, sphere, arrow, controls;
        let stateVector = [[1, 0], [0, 0]]; // Complex representation [real, imag]
        let history = [];
        let rotationAxis = null;
        let rotationAxisHelper = null;
        let isAnimating = false;
        let pathCurve = null;
        let pathLine = null;
        let autoRotate = false;
        
        // é è¨­ç›¸æ©Ÿä½ç½®
        const DEFAULT_CAMERA_POSITION = { x: 4, y: 3, z: 5 };
        
        // åˆå§‹åŒ– Three.js
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f8f8);
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(DEFAULT_CAMERA_POSITION.x, DEFAULT_CAMERA_POSITION.y, DEFAULT_CAMERA_POSITION.z);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // ä½¿ç”¨ OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.8;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.minDistance = 3;
            controls.maxDistance = 10;
            controls.target.set(0, 0, 0);
            controls.update();
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // å‰µå»º Bloch çƒ
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xe0e0e0,
                transparent: true,
                opacity: 0.3,
                wireframe: true
            });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphere);
            
            // æ·»åŠ åº§æ¨™è»¸
            const axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);
            
            // æ·»åŠ è»¸æ¨™ç±¤
            const xLabel = createTextSprite('X', '#f44336');
            xLabel.position.set(1.7, 0, 0);
            scene.add(xLabel);
            
            const yLabel = createTextSprite('Y', '#4caf50');
            yLabel.position.set(0, 1.7, 0);
            scene.add(yLabel);
            
            const zLabel = createTextSprite('Z', '#2196f3');
            zLabel.position.set(0, 0, 1.7);
            scene.add(zLabel);
            
            // æ·»åŠ ç‰¹æ®Šé»æ¨™è¨˜
            addSpecialPoints();
            
            // å‰µå»ºç‹€æ…‹å‘é‡ç®­é ­
            const arrowDirection = new THREE.Vector3(0, 0, 1);
            const arrowOrigin = new THREE.Vector3(0, 0, 0);
            const arrowLength = 1;
            const arrowColor = 0xff0000;
            arrow = new THREE.ArrowHelper(arrowDirection, arrowOrigin, arrowLength, arrowColor, 0.3, 0.2);
            scene.add(arrow);
            
            // æ·»åŠ èµ¤é“åœ“ç’°
            const equatorGeometry = new THREE.RingGeometry(0.98, 1.02, 64);
            const equatorMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
            const equator = new THREE.Mesh(equatorGeometry, equatorMaterial);
            equator.rotation.x = Math.PI / 2;
            scene.add(equator);
            
            // é€Ÿåº¦æ»‘å¡Š
            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            speedSlider.addEventListener('input', (e) => {
                const value = e.target.value / 1000;
                speedValue.textContent = `${value.toFixed(1)} ç§’`;
            });
            
            // è§’åº¦æ»‘å¡Š
            const angleSlider = document.getElementById('angle-slider');
            const angleDisplay = document.getElementById('rotation-angle');
            angleSlider.addEventListener('input', (e) => {
                angleDisplay.textContent = e.target.value;
            });
            
            animate();
        }
        
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            context.font = 'Bold 48px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.5, 0.5, 1);
            return sprite;
        }
        
        function addSpecialPoints() {
            // |0âŸ© åŒ—æ¥µ
            addPoint(0, 0, 1, '|0âŸ©', 0x0000ff);
            // |1âŸ© å—æ¥µ
            addPoint(0, 0, -1, '|1âŸ©', 0x0000ff);
            // |+âŸ© +X
            addPoint(1, 0, 0, '|+âŸ©', 0xff0000);
            // |-âŸ© -X
            addPoint(-1, 0, 0, '|-âŸ©', 0xff0000);
            // |+iâŸ© +Y
            addPoint(0, 1, 0, '|+iâŸ©', 0x00ff00);
            // |-iâŸ© -Y
            addPoint(0, -1, 0, '|-iâŸ©', 0x00ff00);
        }
        
        function addPoint(x, y, z, label, color) {
            const geometry = new THREE.SphereGeometry(0.05, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const point = new THREE.Mesh(geometry, material);
            point.position.set(x, y, z);
            scene.add(point);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update(); // æ›´æ–°æ§åˆ¶å™¨
            
            if (autoRotate && !isAnimating) {
                controls.autoRotate = true;
                controls.autoRotateSpeed = 2.0;
            } else {
                controls.autoRotate = false;
            }
            
            renderer.render(scene, camera);
        }
        
        // é‡ç½®ç›¸æ©Ÿè¦–è§’
        function resetCamera() {
            // å‰µå»ºå¹³æ»‘éæ¸¡å‹•ç•«
            const currentPosition = camera.position.clone();
            const targetPosition = new THREE.Vector3(
                DEFAULT_CAMERA_POSITION.x,
                DEFAULT_CAMERA_POSITION.y,
                DEFAULT_CAMERA_POSITION.z
            );
            
            const tween = new TWEEN.Tween(currentPosition)
                .to(targetPosition, 1000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => {
                    camera.position.copy(currentPosition);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                })
                .start();
                
            // é‡ç½®æ§åˆ¶å™¨
            controls.reset();
            
            document.getElementById('animation-status').textContent = 'è¦–è§’å·²é‡ç½®';
        }
        
        // åˆ‡æ›è‡ªå‹•æ—‹è½‰
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = event.target;
            if (autoRotate) {
                btn.textContent = 'â¸ï¸ åœæ­¢æ—‹è½‰';
                document.getElementById('animation-status').textContent = 'è‡ªå‹•æ—‹è½‰å·²é–‹å•Ÿ';
            } else {
                btn.textContent = 'ğŸ”„ è‡ªå‹•æ—‹è½‰';
                document.getElementById('animation-status').textContent = 'è‡ªå‹•æ—‹è½‰å·²é—œé–‰';
            }
        }
        
        // é¡¯ç¤ºæ—‹è½‰è»¸
        function showRotationAxis(axis, angle) {
            // ç§»é™¤èˆŠçš„æ—‹è½‰è»¸
            if (rotationAxisHelper) {
                scene.remove(rotationAxisHelper);
            }
            
            // å‰µå»ºæ—‹è½‰è»¸
            const origin = new THREE.Vector3(0, 0, 0);
            const direction = axis.normalize();
            const length = 2;
            const color = 0xffff00; // é»ƒè‰²
            
            rotationAxisHelper = new THREE.ArrowHelper(direction, origin, length, color, 0.5, 0.3);
            scene.add(rotationAxisHelper);
            
            // å‹•ç•«çµæŸå¾Œç§»é™¤
            setTimeout(() => {
                if (rotationAxisHelper) {
                    scene.remove(rotationAxisHelper);
                    rotationAxisHelper = null;
                }
            }, parseInt(document.getElementById('speed-slider').value) + 500);
        }
        
        // å‰µå»ºçƒé¢è·¯å¾‘
        function createSphericalPath(startVec, endVec, axis, angle) {
            // ç§»é™¤èˆŠè·¯å¾‘
            if (pathLine) {
                scene.remove(pathLine);
            }
            
            // ç”Ÿæˆçƒé¢ä¸Šçš„è·¯å¾‘é»
            const numPoints = 50;
            const points = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const currentAngle = angle * t;
                
                // ä½¿ç”¨ç¾…å¾·é‡Œæ ¼æ—‹è½‰å…¬å¼
                const cosAngle = Math.cos(currentAngle);
                const sinAngle = Math.sin(currentAngle);
                const oneMinusCos = 1 - cosAngle;
                
                // æ—‹è½‰çŸ©é™£
                const rotMatrix = new THREE.Matrix4();
                const x = axis.x, y = axis.y, z = axis.z;
                
                rotMatrix.set(
                    cosAngle + x * x * oneMinusCos,     x * y * oneMinusCos - z * sinAngle, x * z * oneMinusCos + y * sinAngle, 0,
                    y * x * oneMinusCos + z * sinAngle, cosAngle + y * y * oneMinusCos,     y * z * oneMinusCos - x * sinAngle, 0,
                    z * x * oneMinusCos - y * sinAngle, z * y * oneMinusCos + x * sinAngle, cosAngle + z * z * oneMinusCos,     0,
                    0, 0, 0, 1
                );
                
                // æ‡‰ç”¨æ—‹è½‰
                const point = startVec.clone();
                point.applyMatrix4(rotMatrix);
                points.push(point);
            }
            
            // å‰µå»ºæ›²ç·š
            pathCurve = new THREE.CatmullRomCurve3(points);
            
            // å‰µå»ºè·¯å¾‘ç·š
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff00ff,
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            
            pathLine = new THREE.Line(geometry, material);
            scene.add(pathLine);
        }
        
        // é‡å­é–€çŸ©é™£ï¼ˆä½¿ç”¨è¤‡æ•¸è¡¨ç¤ºï¼‰
        const gates = {
            'X': {
                matrix: [[[0, 0], [1, 0]], [[1, 0], [0, 0]]],
                axis: new THREE.Vector3(1, 0, 0),
                angle: Math.PI
            },
            'Y': {
                matrix: [[[0, 0], [0, -1]], [[0, 1], [0, 0]]],
                axis: new THREE.Vector3(0, 1, 0),
                angle: Math.PI
            },
            'Z': {
                matrix: [[[1, 0], [0, 0]], [[0, 0], [-1, 0]]],
                axis: new THREE.Vector3(0, 0, 1),
                angle: Math.PI
            },
            'H': {
                matrix: [[[1/Math.sqrt(2), 0], [1/Math.sqrt(2), 0]], [[1/Math.sqrt(2), 0], [-1/Math.sqrt(2), 0]]],
                axis: new THREE.Vector3(1/Math.sqrt(2), 0, 1/Math.sqrt(2)),
                angle: Math.PI
            },
            'S': {
                matrix: [[[1, 0], [0, 0]], [[0, 0], [0, 1]]],
                axis: new THREE.Vector3(0, 0, 1),
                angle: Math.PI / 2
            },
            'T': {
                matrix: [[[1, 0], [0, 0]], [[0, 0], [1/Math.sqrt(2), 1/Math.sqrt(2)]]],
                axis: new THREE.Vector3(0, 0, 1),
                angle: Math.PI / 4
            }
        };
        
        // è¤‡æ•¸é‹ç®—
        function complexAdd(a, b) {
            return [a[0] + b[0], a[1] + b[1]];
        }
        
        function complexMultiply(a, b) {
            return [
                a[0] * b[0] - a[1] * b[1],
                a[0] * b[1] + a[1] * b[0]
            ];
        }
        
        function complexMagnitude(c) {
            return Math.sqrt(c[0] * c[0] + c[1] * c[1]);
        }
        
        function complexPhase(c) {
            return Math.atan2(c[1], c[0]);
        }
        
        // å‰µå»ºæ—‹è½‰é–€çŸ©é™£
        function createRotationGate(axis, angle) {
            const halfAngle = angle / 2;
            const cos = Math.cos(halfAngle);
            const sin = Math.sin(halfAngle);
            
            let matrix;
            if (axis === 'x') {
                matrix = [
                    [[cos, 0], [0, -sin]],
                    [[0, -sin], [cos, 0]]
                ];
            } else if (axis === 'y') {
                matrix = [
                    [[cos, 0], [-sin, 0]],
                    [[sin, 0], [cos, 0]]
                ];
            } else if (axis === 'z') {
                matrix = [
                    [[cos, -sin], [0, 0]],
                    [[0, 0], [cos, sin]]
                ];
            }
            
            return matrix;
        }
        
        // æ‡‰ç”¨æ—‹è½‰é–€
        function applyRotationGate(gateName) {
            if (isAnimating) return;
            
            const angleSlider = document.getElementById('angle-slider');
            const angleDegrees = parseFloat(angleSlider.value);
            const angleRadians = angleDegrees * Math.PI / 180;
            
            let axis, axisVector;
            if (gateName === 'Rx') {
                axis = 'x';
                axisVector = new THREE.Vector3(1, 0, 0);
            } else if (gateName === 'Ry') {
                axis = 'y';
                axisVector = new THREE.Vector3(0, 1, 0);
            } else if (gateName === 'Rz') {
                axis = 'z';
                axisVector = new THREE.Vector3(0, 0, 1);
            }
            
            const gate = {
                matrix: createRotationGate(axis, angleRadians),
                axis: axisVector,
                angle: angleRadians
            };
            
            performGateAnimation(gateName + `(${angleDegrees}Â°)`, gate);
        }
        
        // æ‡‰ç”¨é‡å­é–€ï¼ˆå¸¶å‹•ç•«ï¼‰
        function applyGate(gateName) {
            if (isAnimating) return;
            
            const gate = gates[gateName];
            performGateAnimation(gateName, gate);
        }
        
        // åŸ·è¡Œé–€å‹•ç•«
        function performGateAnimation(gateName, gate) {
            if (isAnimating) return;
            
            // æš«åœè‡ªå‹•æ—‹è½‰
            const wasAutoRotating = autoRotate;
            if (autoRotate) {
                autoRotate = false;
            }
            const alpha = stateVector[0];
            const beta = stateVector[1];
            
            // è¨ˆç®—æ–°ç‹€æ…‹
            const newAlpha = complexAdd(
                complexMultiply(gate.matrix[0][0], alpha),
                complexMultiply(gate.matrix[0][1], beta)
            );
            const newBeta = complexAdd(
                complexMultiply(gate.matrix[1][0], alpha),
                complexMultiply(gate.matrix[1][1], beta)
            );
            
            // è¨ˆç®— Bloch åº§æ¨™
            const oldCoords = getBlochCoords(stateVector);
            const newCoords = getBlochCoords([newAlpha, newBeta]);
            
            const startVec = new THREE.Vector3(oldCoords.x, oldCoords.y, oldCoords.z);
            const endVec = new THREE.Vector3(newCoords.x, newCoords.y, newCoords.z);
            
            // é¡¯ç¤ºæ—‹è½‰è»¸
            showRotationAxis(gate.axis, gate.angle);
            
            // å‰µå»ºçƒé¢è·¯å¾‘
            createSphericalPath(startVec, endVec, gate.axis, gate.angle);
            
            // ç¦ç”¨æŒ‰éˆ•å’Œæ§åˆ¶
            setButtonsEnabled(false);
            isAnimating = true;
            controls.enabled = false; // å‹•ç•«æœŸé–“ç¦ç”¨ç›¸æ©Ÿæ§åˆ¶
            
            // æ›´æ–°ç‹€æ…‹
            document.getElementById('animation-status').textContent = 
                `æ­£åœ¨æ‡‰ç”¨ ${gateName} é–€ï¼šç¹ ${getAxisName(gate.axis)} è»¸æ—‹è½‰ ${(gate.angle * 180 / Math.PI).toFixed(0)}Â°`;
            
            // å‹•ç•«
            const duration = parseInt(document.getElementById('speed-slider').value);
            let progress = { t: 0 };
            
            const tween = new TWEEN.Tween(progress)
                .to({ t: 1 }, duration)
                .easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => {
                    if (pathCurve) {
                        const point = pathCurve.getPoint(progress.t);
                        arrow.setDirection(point.normalize());
                    }
                })
                .onComplete(() => {
                    stateVector = [newAlpha, newBeta];
                    
                    // æ›´æ–°æ­·å²
                    const stateString = formatStateVector(newAlpha, newBeta, true);
                    history.push(`${history.length}. ${gateName} é–€ â†’ ${stateString}`);
                    
                    updateDisplay();
                    setButtonsEnabled(true);
                    isAnimating = false;
                    controls.enabled = true; // æ¢å¾©ç›¸æ©Ÿæ§åˆ¶
                    
                    // æ¢å¾©è‡ªå‹•æ—‹è½‰
                    if (wasAutoRotating) {
                        autoRotate = true;
                    }
                    
                    document.getElementById('animation-status').textContent = 'å‹•ç•«å®Œæˆ';
                    
                    // æ·¡å‡ºè·¯å¾‘
                    setTimeout(() => {
                        if (pathLine) {
                            const fadeOut = new TWEEN.Tween({ opacity: 0.8 })
                                .to({ opacity: 0 }, 500)
                                .onUpdate((obj) => {
                                    if (pathLine && pathLine.material) {
                                        pathLine.material.opacity = obj.opacity;
                                    }
                                })
                                .onComplete(() => {
                                    if (pathLine) {
                                        scene.remove(pathLine);
                                        pathLine = null;
                                    }
                                })
                                .start();
                        }
                    }, 500);
                })
                .start();
        }
        
        function getAxisName(axis) {
            if (Math.abs(axis.x) > 0.9) return 'X';
            if (Math.abs(axis.y) > 0.9) return 'Y';
            if (Math.abs(axis.z) > 0.9) return 'Z';
            return 'æ··åˆ';
        }
        
        function setButtonsEnabled(enabled) {
            const buttons = document.querySelectorAll('.gate-btn');
            buttons.forEach(btn => btn.disabled = !enabled);
        }
        
        function getBlochCoords(state) {
            const alpha = state[0];
            const beta = state[1];
            
            const alphaMag = complexMagnitude(alpha);
            const betaMag = complexMagnitude(beta);
            
            let theta = 2 * Math.acos(Math.min(1, alphaMag));
            let phi = 0;
            
            if (betaMag > 0.001) {
                phi = complexPhase(beta) - complexPhase(alpha);
                while (phi < 0) phi += 2 * Math.PI;
                while (phi > 2 * Math.PI) phi -= 2 * Math.PI;
            }
            
            return {
                x: Math.sin(theta) * Math.cos(phi),
                y: Math.sin(theta) * Math.sin(phi),
                z: Math.cos(theta)
            };
        }
        
        // é‡ç½®ç‹€æ…‹
        function resetState() {
            if (isAnimating) return;
            
            // ç§»é™¤è·¯å¾‘
            if (pathLine) {
                scene.remove(pathLine);
                pathLine = null;
            }
            
            stateVector = [[1, 0], [0, 0]];
            history = ['0. é‡ç½® â†’ |0âŸ©'];
            updateDisplay();
            
            // é‡ç½®ç®­é ­
            arrow.setDirection(new THREE.Vector3(0, 0, 1));
            
            document.getElementById('animation-status').textContent = 'å·²é‡ç½®åˆ° |0âŸ©';
        }
        
        // æ ¼å¼åŒ–ç‹€æ…‹å‘é‡ï¼ˆé¡¯ç¤ºç›¸ä½ï¼‰
        function formatStateVector(alpha, beta, showPhase = false) {
            const alphaMag = complexMagnitude(alpha);
            const betaMag = complexMagnitude(beta);
            
            if (alphaMag < 0.01) return '|1âŸ©';
            if (betaMag < 0.01) return '|0âŸ©';
            
            if (showPhase) {
                // æª¢æŸ¥æ˜¯å¦æœ‰è² è™Ÿ
                const alphaPhase = complexPhase(alpha);
                const betaPhase = complexPhase(beta);
                const relativePhase = betaPhase - alphaPhase;
                
                let result = `${alphaMag.toFixed(2)}|0âŸ©`;
                
                if (Math.abs(relativePhase - Math.PI) < 0.1 || Math.abs(relativePhase + Math.PI) < 0.1) {
                    result += ` - ${betaMag.toFixed(2)}|1âŸ©`;
                } else if (Math.abs(relativePhase - Math.PI/2) < 0.1) {
                    result += ` + i${betaMag.toFixed(2)}|1âŸ©`;
                } else if (Math.abs(relativePhase + Math.PI/2) < 0.1 || Math.abs(relativePhase - 3*Math.PI/2) < 0.1) {
                    result += ` - i${betaMag.toFixed(2)}|1âŸ©`;
                } else {
                    result += ` + ${betaMag.toFixed(2)}|1âŸ©`;
                }
                
                return result;
            }
            
            // ç°¡åŒ–é¡¯ç¤º
            return `${alphaMag.toFixed(2)}|0âŸ© + ${betaMag.toFixed(2)}|1âŸ©`;
        }
        
        // æ ¼å¼åŒ–è¤‡æ•¸ç‹€æ…‹
        function formatComplexState(alpha, beta) {
            function formatComplex(c) {
                const real = c[0].toFixed(3);
                const imag = c[1].toFixed(3);
                if (Math.abs(c[1]) < 0.001) return real;
                if (Math.abs(c[0]) < 0.001) return `${imag}i`;
                return `(${real}${imag >= 0 ? '+' : ''}${imag}i)`;
            }
            
            return `Î± = ${formatComplex(alpha)}, Î² = ${formatComplex(beta)}`;
        }
        
        // æ›´æ–°é¡¯ç¤º
        function updateDisplay() {
            const alpha = stateVector[0];
            const beta = stateVector[1];
            
            const coords = getBlochCoords(stateVector);
            
            // æ›´æ–°ç®­é ­æ–¹å‘ï¼ˆä¸åœ¨å‹•ç•«ä¸­ï¼‰
            if (!isAnimating) {
                arrow.setDirection(new THREE.Vector3(coords.x, coords.y, coords.z));
            }
            
            // è¨ˆç®—è§’åº¦
            const alphaMag = complexMagnitude(alpha);
            const betaMag = complexMagnitude(beta);
            
            let theta = 2 * Math.acos(Math.min(1, alphaMag));
            let phi = 0;
            
            if (betaMag > 0.001) {
                phi = complexPhase(beta) - complexPhase(alpha);
                while (phi < 0) phi += 2 * Math.PI;
                while (phi > 2 * Math.PI) phi -= 2 * Math.PI;
            }
            
            // æ›´æ–°æ–‡å­—é¡¯ç¤º
            document.getElementById('state-vector').textContent = 
                `|ÏˆâŸ© = ${formatStateVector(alpha, beta, true)}`;
            document.getElementById('complex-state').textContent = 
                formatComplexState(alpha, beta);
            document.getElementById('bloch-coords').textContent = 
                `Bloch åº§æ¨™: (${coords.x.toFixed(2)}, ${coords.y.toFixed(2)}, ${coords.z.toFixed(2)})`;
            document.getElementById('angles').textContent = 
                `Î¸ = ${(theta * 180 / Math.PI).toFixed(2)}Â°, Ï† = ${(phi * 180 / Math.PI).toFixed(2)}Â°`;
            
            // æ›´æ–°æ¸¬é‡æ©Ÿç‡
            const prob0 = alphaMag * alphaMag;
            const prob1 = betaMag * betaMag;
            document.getElementById('prob0').textContent = `${(prob0 * 100).toFixed(1)}%`;
            document.getElementById('prob1').textContent = `${(prob1 * 100).toFixed(1)}%`;
            document.getElementById('prob0-bar').style.width = `${prob0 * 100}%`;
            document.getElementById('prob1-bar').style.width = `${prob1 * 100}%`;
            
            // æ›´æ–°æ­·å²
            const historyHtml = history.slice(-10).map(item => 
                `<div class="history-item">${item}</div>`
            ).join('');
            document.getElementById('history-list').innerHTML = historyHtml;
            
            // è‡ªå‹•æ»¾å‹•åˆ°åº•éƒ¨
            const historyDiv = document.getElementById('history-list').parentElement;
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }
        
        // åˆå§‹åŒ–
        window.onload = function() {
            initThreeJS();
            resetState();
        };
        
        window.onresize = function() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        };
    </script>
</body>
</html>